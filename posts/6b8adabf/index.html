<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0"><link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.4.0"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.4.0",exturl:!1,sidebar:{position:"right",display:"hide",offset:12,onmobile:!0},copycode:{enable:!0,show_result:!0,style:"flat"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#999",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:-1,unescape:!0,preload:!0},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"},sidebarPadding:40}</script><meta name="description" content="➡️了解 DockerDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux基金会，并成立推动 开放容器联盟（OCI）。"><meta name="keywords" content="linux,docker,虚拟化"><meta property="og:type" content="article"><meta property="og:title" content="Docker学习笔记"><meta property="og:url" content="https://hexo.lilis.xin/posts/6b8adabf/index.html"><meta property="og:site_name" content="小叽の博客"><meta property="og:description" content="➡️了解 DockerDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux基金会，并成立推动 开放容器联盟（OCI）。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/84118f50.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/1ccc2aa9e11e25e5ed2efd18cf1052c4.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/a20b70e3e4ca61faa2c3436e1bb2d93a.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/39fb0f8e630b338bcca7a29da3acabb7.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/f3218a8fcdd1fd8bcd5a719ca3c64f59.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/53e377deeeb5f30bf939ed0836f851c9.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/062e7af0929dd205b2ac6efdd937d6f4.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/162f02c6f9dce4ccdaa0c6c676da2196.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/1c38d4735e9760bdca025ff50a1b5386.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/01aedf55bd21abbe607b3864d76f0ec0.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/275cc486d4ce7ecbdecf0ecc1de0a34b.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/f05a2a8dfc6641d8237306ff575aa283.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/d7f7b0ada7fc1c641c90745a959f9c05.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/d5b0b3e2e7acdcf35e7577d7670a46f7.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/ce083575e95a0e46b105c3596c12ca71.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/a41de8fe542efe25e3620691ad9238df.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/ac1cbc31d4f191e26e05fb1a11f04d26.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/b701a3c51e7d1915da3bea0bc43efcd1.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/8fa2d6e19c29f18548624efd64eb6dfa.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/32a7f413a5f8ff936dd0f4a31d25fdcc.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/3c02ccf4e7a2a353af065d93b26ae89e.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/28059b3a499faba896263c0ff077fe3a.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/b22cd304f28c715ae3ae6812476b222d.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/100712263ecf4544dd11602adc39ee3e.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/db64b3b38aff136d42e9ffeb81675bda.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/184f9d55770ca036cb5b1e6d96ce4a12.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/70cdbaf975c88bc83423d88be85476b5.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/1714c3dd524c807bf9c9b4d0fbe4d056.png"><meta property="og:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/b513dd5467f23fdd23523f60242d5dcb.png"><meta property="og:updated_time" content="2019-09-26T03:05:52.148Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Docker学习笔记"><meta name="twitter:description" content="➡️了解 DockerDocker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux基金会，并成立推动 开放容器联盟（OCI）。"><meta name="twitter:image" content="https://hexo.lilis.xin/posts/6b8adabf/images/84118f50.png"><link rel="alternate" href="/atom.xml" title="小叽の博客" type="application/atom+xml"><link rel="canonical" href="https://hexo.lilis.xin/posts/6b8adabf/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>Docker学习笔记 | 小叽の博客</title><meta name="generator" content="Hexo 3.9.0"><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container use-motion"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">小叽の博客</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article itemscope itemtype="http://schema.org/Article"><div class="post-block post"><link itemprop="mainEntityOfPage" href="https://hexo.lilis.xin/posts/6b8adabf/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="小叽"><meta itemprop="description" content=""><meta itemprop="image" content="/images/head.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小叽の博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Docker学习笔记</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-09-20 09:42:31" itemprop="dateCreated datePublished" datetime="2019-09-20T09:42:31+08:00">2019-09-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2019-09-26 11:05:52" itemprop="dateModified" datetime="2019-09-26T11:05:52+08:00">2019-09-26</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="了解-docker"><a class="header-anchor" href="#了解-docker">➡️</a>了解 Docker</h3><blockquote><p><code>Docker</code> 最初是 <code>dotCloud</code> 公司创始人 <code>Solomon Hykes</code> 在法国期间发起的一个公司内部项目，它是基于 <code>dotCloud</code> 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 <code>GitHub</code> 上进行维护。<code>Docker</code> 项目后来还加入了 <code>Linux基金会</code>，并成立推动 开放容器联盟（OCI）。</p><a id="more"></a><p><code>Docker</code> 自开源后受到广泛的关注和讨论，至今其 <code>GitHub</code> 项目 已经超过 5 万 2 千个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 2013 年底，<code>dotCloud</code> 公司决定改名为 <code>Docker</code>。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。<br><code>Docker</code> 使用 <code>Google</code> 公司推出的 <code>Go</code> 语言 进行开发实现，基于 <code>Linux</code> 内核的 <code>cgroup</code>，<code>namespace</code>，以及 <code>AUFS</code> 类的 <code>Union FS</code> 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <code>LXC</code>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <code>libcontainer</code>，从 <code>1.11</code> 开始，则进一步演进为使用 <code>runC</code> 和 <code>containerd</code>。</p><footer><strong>Docker — 从入门到实践</strong><cite><a href="https://yeasy.gitbooks.io/docker_practice/introduction/what.html" target="_blank" rel="noopener">什么是 Docker</a></cite></footer></blockquote><img src="images/84118f50.png"><h3 id="docker-生命周期"><a class="header-anchor" href="#docker-生命周期">➡️</a>Docker 生命周期</h3><p>Docker 包括三个基本概念</p><ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul><p>容器是由镜像实例化而来的，可以理解成容器是镜像的基础备份，当Docker实例化一个容器时，相当于把这个镜像备份一份，然后在这个备份的基础上启动，开始各种操作。<br>我们可以把镜像想象成类,把容器想象成类经过实例化后的对象。</p><h4 id="docker-镜像"><a class="header-anchor" href="#docker-镜像">➡️</a>Docker 镜像</h4><p><code>Docker</code>的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。<br>例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了Mysql或用户需要的其它应用程序。<br><code>Docker</code>的镜像实际上由一层一层的文件系统组成，这种层级的文件系统被称为UnionFS。镜像可以基于<code>Dockerfile</code>构建，<code>Dockerfile</code>是一个描述文件，里面包含若干条命令，每条命令都会对基础文件系统创建新的层次结构。<br><code>Docker</code>提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p><div class="note info"><p>注：镜像是只读的，可以理解为静态文件。</p></div><p>镜像是一堆<code>只读层（read-only layer）</code>的统一视角，那些<code>只读层</code>重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是<code>Docker</code>内部的实现细节，并且能够在主机（运行<code>Docker</code>的机器）的文件系统上访问到。<code>统一文件系统（union file system）</code>技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。</p><div class="note info"><p>注：<code>Docker</code>在linux上共享内核，无需虚拟化，完全支持native功能。<br><code>Docker</code>在windows上，启用<code>Hyper-V</code>或者<code>虚拟化技术</code>，通过虚拟机来实现，不共享windows内核。<br><code>Docker</code>在macOS上，同样用虚拟化技术<code>xhyve</code>或者<code>virtualbox</code>来实现，不共享macOS内核。<br>所以，在macOS和Windows下是无法直接访问到镜像的文件的。</p></div><h4 id="docker-容器"><a class="header-anchor" href="#docker-容器">➡️</a>Docker 容器</h4><p><code>Docker</code>利用容器来运行应用。<br><code>容器（container）</code>和<code>镜像（image）</code>的几乎一样，区别就是<code>容器</code>的最上面一层是可读写的</p><div class="note info"><p>注：相对于镜像来说容器是动态的，容器在启动的时候创建一层可写层作为最上层。<br>容器的定义并没有提及容器是否在运行。</p></div><h5 id="running-container-definition"><a class="header-anchor" href="#running-container-definition">➡️</a>Running Container Definition</h5><p>一个<code>运行态容器（running container）</code>被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程。</p><img src="images/1ccc2aa9e11e25e5ed2efd18cf1052c4.png"><p>一个容器中的进程对着个容器里的文件进行增加，删除，修改操作都将作用于容器中最上面的那一层可读写层。</p><img src="images/a20b70e3e4ca61faa2c3436e1bb2d93a.png"><h5 id="image-layer-definition"><a class="header-anchor" href="#image-layer-definition">➡️</a>Image Layer Definition</h5><p><code>镜像层（image layer）</code>表示一层中的各种零零星星的数据，它并不仅仅包含文件系统的改变，还能包含了其他重要信息。</p><img src="images/39fb0f8e630b338bcca7a29da3acabb7.png"><p><code>元数据（metadata）</code>就是关于这个层的额外信息，它不仅能够让<code>Docker</code>获取运行和构建时的信息，还包括父层的层次信息。需要注意，只读层和读写层都包含元数据。</p><img src="images/f3218a8fcdd1fd8bcd5a719ca3c64f59.png"><p>除此之外，每一层都包括了一个指向父层的指针。如果一个层没有这个指针，说明它处于最底层。</p><img src="images/53e377deeeb5f30bf939ed0836f851c9.png"><h4 id="docker-仓库"><a class="header-anchor" href="#docker-仓库">➡️</a>Docker 仓库</h4><p>如果你使用过git和github就很容易理解Docker的仓库概念。Docker 仓库的概念跟Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。<br>Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。<br>仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p><h4 id="全局理解-tying-it-all-together"><a class="header-anchor" href="#全局理解-tying-it-all-together">➡️</a>全局理解（Tying It All Together）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create &lt;image-id&gt;</span><br></pre></td></tr></table></figure><img src="images/062e7af0929dd205b2ac6efdd937d6f4.png"><p><code>docker create</code>命令为指定的<code>镜像（image）</code>创建了一个可读可写层，构成了一个新的容器。注意，这个容器并没有运行。</p><img src="images/162f02c6f9dce4ccdaa0c6c676da2196.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;container-id&gt;</span><br></pre></td></tr></table></figure><img src="images/1c38d4735e9760bdca025ff50a1b5386.png"><p><code>Docker start</code>命令为容器文件系统创建了一个进程隔离空间。注意，每一个容器只能够有一个进程隔离空间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run &lt;image-id&gt;</span><br></pre></td></tr></table></figure><img src="images/01aedf55bd21abbe607b3864d76f0ec0.png"><p><code>docker start</code>和<code>docker run</code>命令的区别。</p><img src="images/275cc486d4ce7ecbdecf0ecc1de0a34b.png"><p>从图片可以看出，<code>docker run</code>命令先是利用镜像创建了一个容器，然后运行这个容器。这个命令非常的方便，并且隐藏了两个命令的细节，但从另一方面来看，这容易让用户产生误解。</p><div class="note info"><p>注：<code>docker run</code>相当于<code>docker create</code>和<code>docker start</code>两个命令的组合。</p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><img src="images/f05a2a8dfc6641d8237306ff575aa283.png"><p><code>docker ps</code>命令会列出所有运行中的容器。这隐藏了非运行态容器的存在。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure><img src="images/d7f7b0ada7fc1c641c90745a959f9c05.png"><p><code>docker ps –a</code>命令会列出所有的容器，不管是运行的，还是停止的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><img src="images/d5b0b3e2e7acdcf35e7577d7670a46f7.png"><p><code>docker images</code>命令会列出了所有<code>顶层（top-level）镜像</code>。实际上，在这里我们没有办法区分一个镜像和一个只读层，所以我们提出了<code>top-level镜像</code>。只有创建容器时使用的镜像或者是直接pull下来的镜像能被称为<code>顶层（top-level）镜像</code>，并且每一个顶层镜像下面都隐藏了多个镜像层。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images –a</span><br></pre></td></tr></table></figure><img src="images/ce083575e95a0e46b105c3596c12ca71.png"><p><code>docker images –a</code>命令列出了所有的镜像，也可以说是列出了所有的可读层。如果你想要查看某一个<code>image-id</code>下的所有层，可以使用<code>docker history</code>来查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;container-id&gt;</span><br></pre></td></tr></table></figure><img src="images/a41de8fe542efe25e3620691ad9238df.png"><p><code>docker stop</code>命令会向运行中的容器发送一个<code>SIGTERM</code>的信号，然后停止所有的进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill &lt;container-id&gt;</span><br></pre></td></tr></table></figure><img src="images/ac1cbc31d4f191e26e05fb1a11f04d26.png"><p><code>docker kill</code>命令向所有运行在容器中的进程发送了一个不友好的<code>SIGKILL</code>信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause &lt;container-id&gt;</span><br></pre></td></tr></table></figure><img src="images/b701a3c51e7d1915da3bea0bc43efcd1.png"><p><code>docker stop</code>和<code>docker kill</code>命令会发送UNIX的信号给运行中的进程，<code>docker pause</code>命令则不一样，它利用了<code>cgroups</code>的特性将运行中的进程空间暂停。但是这种方式的不足之处在于发送一个<code>SIGTSTP</code>信号对于进程来说不够简单易懂，以至于不能够让所有进程暂停。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;container-id&gt;</span><br></pre></td></tr></table></figure><img src="images/8fa2d6e19c29f18548624efd64eb6dfa.png"><p><code>docker rm</code>命令会移除构成容器的可读写层。注意，这个命令只能对非运行态容器执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi &lt;image-id&gt;</span><br></pre></td></tr></table></figure><img src="images/32a7f413a5f8ff936dd0f4a31d25fdcc.png"><p><code>docker rmi</code>命令会移除构成镜像的一个只读层。你只能够使用<code>docker rmi</code>来移除<code>最顶层（top level layer）</code>（也可以说是镜像），你也可以使用<code>-f</code>参数来强制删除中间的只读层。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit &lt;container-id&gt;</span><br></pre></td></tr></table></figure><img src="images/3c02ccf4e7a2a353af065d93b26ae89e.png"><p><code>docker commit</code>命令将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像。</p><img src="images/28059b3a499faba896263c0ff077fe3a.png"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build</span><br></pre></td></tr></table></figure><img src="images/b22cd304f28c715ae3ae6812476b222d.png"><p><code>docker build</code>命令会反复的执行多个命令。</p><img src="images/100712263ecf4544dd11602adc39ee3e.png"><p><code>build</code>命令根据<code>Dockerfile</code>文件中的<code>FROM</code>指令获取到镜像，然后重复地</p><ol><li><code>run（create和start）</code></li><li>修改</li><li>commit</li></ol><p>在循环中的每一步都会生成一个新的层，因此许多新的层会被创建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec &lt;running-container-id&gt;</span><br></pre></td></tr></table></figure><img src="images/db64b3b38aff136d42e9ffeb81675bda.png"><p><code>docker exec</code>命令会在运行中的容器执行一个新进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;container-id&gt; or &lt;image-id&gt;</span><br></pre></td></tr></table></figure><img src="images/184f9d55770ca036cb5b1e6d96ce4a12.png"><p><code>docker inspect</code>命令会提取出容器或者镜像最顶层的元数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save &lt;image-id&gt;</span><br></pre></td></tr></table></figure><img src="images/70cdbaf975c88bc83423d88be85476b5.png"><p><code>docker save</code>命令会创建一个镜像的压缩文件，这个文件能够在另外一个主机的<code>Docker</code>上使用。和<code>export</code>命令不同，这个命令为每一个层都保存了它们的元数据。这个命令只能对镜像生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export &lt;container-id&gt;</span><br></pre></td></tr></table></figure><img src="images/1714c3dd524c807bf9c9b4d0fbe4d056.png"><p><code>docker export</code>命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容。</p><div class="note info"><p>注：<code>expoxt</code>后的容器再<code>import</code>到<code>Docker</code>中，通过<code>docker images –tree</code>命令只能看到一个镜像；而<code>save</code>后的镜像则不同，它能够看到这个镜像的历史镜像。</p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history &lt;image-id&gt;</span><br></pre></td></tr></table></figure><img src="images/b513dd5467f23fdd23523f60242d5dcb.png"><p><code>docker history</code>命令递归地输出指定镜像的历史镜像。</p><div class="note info"><p>参考链接：</p><ul><li><a href="https://merrigrove.blogspot.com/2015/10/visualizing-docker-containers-and-images.html" title="Visualizing Docker Containers and Images" target="_blank" rel="noopener">Visualizing Docker Containers and Images</a></li><li><a href="http://dockone.io/article/783" title="10张图带你深入理解Docker容器和镜像" target="_blank" rel="noopener">10张图带你深入理解Docker容器和镜像</a></li></ul></div><h3 id="docker-命令"><a class="header-anchor" href="#docker-命令">➡️</a>Docker 命令</h3><a href="https://www.runoob.com/docker/docker-command-manual.html" title="Docker 命令大全" target="_blank" rel="noopener">参考链接</a><h4 id="docker-run"><a class="header-anchor" href="#docker-run">➡️</a>Docker run</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-P: 随机端口映射，容器内部端口随机映射到主机的高端口</li><li>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name=“nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>–dns-search <a href="http://example.com" target="_blank" rel="noopener">example.com</a>: 指定容器DNS搜索域名，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username=“ritchie”: 设置环境变量；</li><li>–env-file=[]: 从指定文件读入环境变量；</li><li>–cpuset=“0-2” or --cpuset=“0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net=“bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li>–link=[]: 添加链接到另一个容器；</li><li>–expose=[]: 开放一个端口或一组端口；</li><li>–volume , -v: 绑定一个卷</li></ul><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</span></span><br><span class="line">docker run --name mynginx -d nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</span></span><br><span class="line">docker run -P -d nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</span></span><br><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span></span><br><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@b85456f75:/#</span><br></pre></td></tr></table></figure><h4 id="docker-start-stop-restart-命令"><a class="header-anchor" href="#docker-start-stop-restart-命令">➡️</a>Docker start/stop/restart 命令</h4><p><code>docker start</code> :启动一个或多个已经被停止的容器<br><code>docker stop</code> :停止一个运行中的容器<br><code>docker restart</code> :重启容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动已被停止的容器myrunoob</span></span><br><span class="line">docker start myrunoob</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止运行中的容器myrunoob</span></span><br><span class="line">docker stop myrunoob</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启容器myrunoob</span></span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure><h4 id="docker-attach-命令"><a class="header-anchor" href="#docker-attach-命令">➡️</a>Docker attach 命令</h4><p><code>docker attach</code>:连接到正在运行中的容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。<br>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p><h4 id="docker-create-命令"><a class="header-anchor" href="#docker-create-命令">➡️</a>Docker create 命令</h4><p>创建一个新的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><h5 id="options"><a class="header-anchor" href="#options">➡️</a>Options</h5><table><thead><tr><th>Name,shorthand</th><th style="text-align:center">Default</th><th>Description</th></tr></thead><tbody><tr><td>–add-host</td><td style="text-align:center"></td><td>Add a custom host-to-IP mapping (host:ip)</td></tr><tr><td>–attach , -a</td><td style="text-align:center"></td><td>Attach to STDIN, STDOUT or STDERR</td></tr><tr><td>–blkio-weight</td><td style="text-align:center"></td><td>Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)</td></tr><tr><td>–blkio-weight-device</td><td style="text-align:center"></td><td>Block IO weight (relative device weight)</td></tr><tr><td>–cap-add</td><td style="text-align:center"></td><td>Add Linux capabilities</td></tr><tr><td>–cap-drop</td><td style="text-align:center"></td><td>Drop Linux capabilities</td></tr><tr><td>–cgroup-parent</td><td style="text-align:center"></td><td>Optional parent cgroup for the container</td></tr><tr><td>–cidfile</td><td style="text-align:center"></td><td>Write the container ID to the file</td></tr><tr><td>–cpu-count</td><td style="text-align:center"></td><td>CPU count (Windows only)</td></tr><tr><td>–cpu-percent</td><td style="text-align:center"></td><td>CPU percent (Windows only)</td></tr><tr><td>–cpu-period</td><td style="text-align:center"></td><td>Limit CPU CFS (Completely Fair Scheduler) period</td></tr><tr><td>–cpu-quota</td><td style="text-align:center"></td><td>Limit CPU CFS (Completely Fair Scheduler) quota</td></tr><tr><td>–cpu-rt-period</td><td style="text-align:center"></td><td><code>API 1.25+</code><br>Limit CPU real-time period in microseconds</td></tr><tr><td>–cpu-rt-runtime</td><td style="text-align:center"></td><td><code>API 1.25+</code><br>Limit CPU real-time runtime in microseconds</td></tr><tr><td>–cpu-shares , -c</td><td style="text-align:center"></td><td>CPU shares (relative weight)</td></tr><tr><td>–cpus</td><td style="text-align:center"></td><td><code>API 1.25+</code><br>Number of CPUs</td></tr><tr><td>–cpuset-cpus</td><td style="text-align:center"></td><td>CPUs in which to allow execution (0-3, 0,1)</td></tr><tr><td>–cpuset-mems</td><td style="text-align:center"></td><td>MEMs in which to allow execution (0-3, 0,1)</td></tr><tr><td>–device</td><td style="text-align:center"></td><td>Add a host device to the container</td></tr><tr><td>–device-cgroup-rule</td><td style="text-align:center"></td><td>Add a rule to the cgroup allowed devices list</td></tr><tr><td>–device-read-bps</td><td style="text-align:center"></td><td>Limit read rate (bytes per second) from a device</td></tr><tr><td>–device-read-iops</td><td style="text-align:center"></td><td>Limit read rate (IO per second) from a device</td></tr><tr><td>–device-write-bps</td><td style="text-align:center"></td><td>Limit write rate (bytes per second) to a device</td></tr><tr><td>–device-write-iops</td><td style="text-align:center"></td><td>Limit write rate (IO per second) to a device</td></tr><tr><td>–disable-content-trust</td><td style="text-align:center">true</td><td>Skip image verification</td></tr><tr><td>–dns</td><td style="text-align:center"></td><td>Set custom DNS servers</td></tr><tr><td>–dns-opt</td><td style="text-align:center"></td><td>Set DNS options</td></tr><tr><td>–dns-option</td><td style="text-align:center"></td><td>Set DNS options</td></tr><tr><td>–dns-search</td><td style="text-align:center"></td><td>Set custom DNS search domains</td></tr><tr><td>–domainname</td><td style="text-align:center"></td><td>Container NIS domain name</td></tr><tr><td>–entrypoint</td><td style="text-align:center"></td><td>Overwrite the default ENTRYPOINT of the image</td></tr><tr><td>–env , -e</td><td style="text-align:center"></td><td>Set environment variables</td></tr><tr><td>–env-file</td><td style="text-align:center"></td><td>Read in a file of environment variables</td></tr><tr><td>–expose</td><td style="text-align:center"></td><td>Expose a port or a range of ports</td></tr><tr><td>–gpus</td><td style="text-align:center"></td><td><code>API 1.40+</code><br>GPU devices to add to the container (‘all’ to pass all GPUs)</td></tr><tr><td>–group-add</td><td style="text-align:center"></td><td>Add additional groups to join</td></tr><tr><td>–health-cmd</td><td style="text-align:center"></td><td>Command to run to check health</td></tr><tr><td>–health-interval</td><td style="text-align:center"></td><td>Time between running the check (ms丨s丨m丨h) (default 0s)</td></tr><tr><td>–health-retries</td><td style="text-align:center"></td><td>Consecutive failures needed to report unhealthy</td></tr><tr><td>–health-start-period</td><td style="text-align:center"></td><td><code>API 1.29+</code><br>Start period for the container to initialize before starting health-retries countdown (ms丨s&amp;丨m丨h) (default 0s)</td></tr><tr><td>–health-timeout</td><td style="text-align:center"></td><td>Maximum time to allow one check to run (ms丨s丨m丨h) (default 0s)</td></tr><tr><td>–help</td><td style="text-align:center"></td><td>Print usage</td></tr><tr><td>–hostname , -h</td><td style="text-align:center"></td><td>Container host name</td></tr><tr><td>–init</td><td style="text-align:center"></td><td><code>API 1.25+</code><br>Run an init inside the container that forwards signals and reaps processes</td></tr><tr><td>–interactive , -i</td><td style="text-align:center"></td><td>Keep STDIN open even if not attached</td></tr><tr><td>–io-maxbandwidth</td><td style="text-align:center"></td><td>Maximum IO bandwidth limit for the system drive (Windows only)</td></tr><tr><td>–io-maxiops</td><td style="text-align:center"></td><td>Maximum IOps limit for the system drive (Windows only)</td></tr><tr><td>–ip</td><td style="text-align:center"></td><td>IPv4 address (e.g., 172.30.100.104)</td></tr><tr><td>–ip6</td><td style="text-align:center"></td><td>IPv6 address (e.g., 2001:db8::33)</td></tr><tr><td>–ipc</td><td style="text-align:center"></td><td>IPC mode to use</td></tr><tr><td>–isolation</td><td style="text-align:center"></td><td>Container isolation technology</td></tr><tr><td>–kernel-memory</td><td style="text-align:center"></td><td>Kernel memory limit</td></tr><tr><td>–label , -l</td><td style="text-align:center"></td><td>Set meta data on a container</td></tr><tr><td>–label-file</td><td style="text-align:center"></td><td>Read in a line delimited file of labels</td></tr><tr><td>–link</td><td style="text-align:center"></td><td>Add link to another container</td></tr><tr><td>–link-local-ip</td><td style="text-align:center"></td><td>Container IPv4/IPv6 link-local addresses</td></tr><tr><td>–log-driver</td><td style="text-align:center"></td><td>Logging driver for the container</td></tr><tr><td>–log-opt</td><td style="text-align:center"></td><td>Log driver options</td></tr><tr><td>–mac-address</td><td style="text-align:center"></td><td>Container MAC address (e.g., 92:d0:c6:0a:29:33)</td></tr><tr><td>–memory , -m</td><td style="text-align:center"></td><td>Memory limit</td></tr><tr><td>–memory-reservation</td><td style="text-align:center"></td><td>Memory soft limit</td></tr><tr><td>–memory-swap</td><td style="text-align:center"></td><td>Swap limit equal to memory plus swap: ‘-1’ to enable unlimited swap</td></tr><tr><td>–memory-swappiness</td><td style="text-align:center">-1</td><td>Tune container memory swappiness (0 to 100)</td></tr><tr><td>–mount</td><td style="text-align:center"></td><td>Attach a filesystem mount to the container</td></tr><tr><td>–name</td><td style="text-align:center"></td><td>Assign a name to the container</td></tr><tr><td>–net</td><td style="text-align:center"></td><td>Connect a container to a network</td></tr><tr><td>–net-alias</td><td style="text-align:center"></td><td>Add network-scoped alias for the container</td></tr><tr><td>–network</td><td style="text-align:center"></td><td>Connect a container to a network</td></tr><tr><td>–network-alias</td><td style="text-align:center"></td><td>Add network-scoped alias for the container</td></tr><tr><td>–no-healthcheck</td><td style="text-align:center"></td><td>Disable any container-specified HEALTHCHECK</td></tr><tr><td>–oom-kill-disable</td><td style="text-align:center"></td><td>Disable OOM Killer</td></tr><tr><td>–oom-score-adj</td><td style="text-align:center"></td><td>Tune host’s OOM preferences (-1000 to 1000)</td></tr><tr><td>–pid</td><td style="text-align:center"></td><td>PID namespace to use</td></tr><tr><td>–pids-limit</td><td style="text-align:center"></td><td>Tune container pids limit (set -1 for unlimited)</td></tr><tr><td>–platform</td><td style="text-align:center"></td><td><code>experimental (daemon)API 1.32+</code><br>Set platform if server is multi-platform capable</td></tr><tr><td>–privileged</td><td style="text-align:center"></td><td>Give extended privileges to this container</td></tr><tr><td>–publish , -p</td><td style="text-align:center"></td><td>Publish a container’s port(s) to the host</td></tr><tr><td>–publish-all , -P</td><td style="text-align:center"></td><td>Publish all exposed ports to random ports</td></tr><tr><td>–read-only</td><td style="text-align:center"></td><td>Mount the container’s root filesystem as read only</td></tr><tr><td>–restart</td><td style="text-align:center">no</td><td>Restart policy to apply when a container exits</td></tr><tr><td>–rm</td><td style="text-align:center"></td><td>Automatically remove the container when it exits</td></tr><tr><td>–runtime</td><td style="text-align:center"></td><td>Runtime to use for this container</td></tr><tr><td>–security-opt</td><td style="text-align:center"></td><td>Security Options</td></tr><tr><td>–shm-size</td><td style="text-align:center"></td><td>Size of /dev/shm</td></tr><tr><td>–stop-signal</td><td style="text-align:center">SIGTERM</td><td>Signal to stop a container</td></tr><tr><td>–stop-timeout</td><td style="text-align:center"></td><td><code>API 1.25+</code><br>Timeout (in seconds) to stop a container</td></tr><tr><td>–storage-opt</td><td style="text-align:center"></td><td>Storage driver options for the container</td></tr><tr><td>–sysctl</td><td style="text-align:center"></td><td>Sysctl options</td></tr><tr><td>–tmpfs</td><td style="text-align:center"></td><td>Mount a tmpfs directory</td></tr><tr><td>–tty , -t</td><td style="text-align:center"></td><td>Allocate a pseudo-TTY</td></tr><tr><td>–ulimit</td><td style="text-align:center"></td><td>Ulimit options</td></tr><tr><td>–user , -u</td><td style="text-align:center"></td><td>Username or UID (format: &lt;name丨uid&gt;[:&lt;group丨gid&gt;])</td></tr><tr><td>–userns</td><td style="text-align:center"></td><td>User namespace to use</td></tr><tr><td>–uts</td><td style="text-align:center"></td><td>UTS namespace to use</td></tr><tr><td>–volume , -v</td><td style="text-align:center"></td><td>Bind mount a volume</td></tr><tr><td>–volume-driver</td><td style="text-align:center"></td><td>Optional volume driver for the container</td></tr><tr><td>–volumes-from</td><td style="text-align:center"></td><td>Mount volumes from the specified container(s)</td></tr><tr><td>–workdir , -w</td><td style="text-align:center"></td><td>Working directory inside the container</td></tr></tbody></table></div><footer class="post-footer"><div class="post-tags"><a href="/tags/linux/" rel="tag"># linux</a> <a href="/tags/docker/" rel="tag"># docker</a> <a href="/tags/虚拟化/" rel="tag"># 虚拟化</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/44125ab6/" rel="next" title="hexo 配置gitalk"><i class="fa fa-chevron-left"></i> hexo 配置gitalk</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/907e528c/" rel="prev" title="CentOS 7安装TCP BBR拥塞算法">CentOS 7安装TCP BBR拥塞算法 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="gitalk-container"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#了解-docker"><span class="nav-number">1.</span> <span class="nav-text">➡️了解 Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-生命周期"><span class="nav-number">2.</span> <span class="nav-text">➡️Docker 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-镜像"><span class="nav-number">2.1.</span> <span class="nav-text">➡️Docker 镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-容器"><span class="nav-number">2.2.</span> <span class="nav-text">➡️Docker 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#running-container-definition"><span class="nav-number">2.2.1.</span> <span class="nav-text">➡️Running Container Definition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#image-layer-definition"><span class="nav-number">2.2.2.</span> <span class="nav-text">➡️Image Layer Definition</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-仓库"><span class="nav-number">2.3.</span> <span class="nav-text">➡️Docker 仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全局理解-tying-it-all-together"><span class="nav-number">2.4.</span> <span class="nav-text">➡️全局理解（Tying It All Together）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-命令"><span class="nav-number">3.</span> <span class="nav-text">➡️Docker 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-run"><span class="nav-number">3.1.</span> <span class="nav-text">➡️Docker run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-start-stop-restart-命令"><span class="nav-number">3.2.</span> <span class="nav-text">➡️Docker start/stop/restart 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-attach-命令"><span class="nav-number">3.3.</span> <span class="nav-text">➡️Docker attach 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#docker-create-命令"><span class="nav-number">3.4.</span> <span class="nav-text">➡️Docker create 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#options"><span class="nav-number">3.4.1.</span> <span class="nav-text">➡️Options</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/head.png" alt="小叽"><p class="site-author-name" itemprop="name">小叽</p><div class="site-description" itemprop="description"></div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">56</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/l552121229" title="GitHub &rarr; https://github.com/l552121229" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:552121229l@gmail.com" title="E-Mail &rarr; mailto:552121229l@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://blog.caoxl.com/" title="https://blog.caoxl.com/" rel="noopener" target="_blank">Keep It Simple And Stupid</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">小叽</span></div><div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div><span class="post-meta-divider">|</span> <span>&nbsp;<a href="http://www.beian.miit.gov.cn/">粤ICP备18140559号</a>&nbsp;</span><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.0</div></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script><script src="/js/schemes/muse.js?v=7.4.0"></script><script src="/js/next-boot.js?v=7.4.0"></script><script src="/js/local-search.js?v=7.4.0"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '03bad61b5e430dca9413',
      clientSecret: 'bd73e83ab1d1764598a44f6324c7842d162372c6',
      repo: 'l552121229.github.io.comments',
      owner: 'l552121229',
      admin: ['l552121229'],
      id: '793c48fb5fc3e2108388ed6c2b1d6b61',
        language: window.navigator.language || window.navigator.userLanguage,
      
      distractionFreeMode: 'true'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>